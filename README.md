# The Setup

  We have tested this with GHC `8.4.1`.

# The Bug

  Some process in the compilation pipeline is leaking huge amounts of
  memory. Our hypothesis was that the exhaustiveness checker was the culprit,
  and hence we tried to gradually introduce more and more pattern
  synonyms to try to help the compiler. 

  Two interesting things happened:

  1. Introducing pattern synonyms for singletons of type-level naturals
  seems to really help (`Minimal2`).

  2. Introducing pattern synonyms for injections into the `NS` datatype
  deteriorate the behavior. Moreover, if these patterns are not accompained
  by signatures, the compiler throws error on big cases.
  
# Data in this Repository

  1. Splices generated by our Template Haskell code (under `Raw` folder)
  2. Scripts for processing these splices into self-contained repros.
  3. A couple reproducibles inside `Processed`.

# Differences between reproducibles

  The files under `Example` illustrate the addition of information 
from each reproducible to the next. In summary:

  - **from 1 to 2:** added pattern synonyms for `Nat` and their singletons.
  - **from 2 to 3:** added pattern synonyms for injections into `NS`.
  - **from 3 to 4:** added type signatures to the pattern synonyms for
                     `NS` injections.

## Processed/Minimal1 

  -  Analogous to the example attached in [our trac ticket](https://ghc.haskell.org/trac/ghc/ticket/14987). It is a little messier since it was generated
by scripts.

  - Consumes about 3.5 GB of Ram

## Processed/Minimal2

  Trying to avoid the exhaustiveness checker we decided to introduce
a number of type and pattern synonyms for the `Nat` kind and `SNat` type:

```haskell
data Nat = Z | S Nat

data SNat :: Nat -> * where
  SZ :: SNat Z
  SS :: SNat n -> SNat (S n)
```

  The pattern synonyms look like:

```haskell
type D0_ = Z
type D1_ = S Z
type D2_ = S (S Z)
...

pattern IdxA = SZ
pattern IdxB = SS SZ
...
```

  - Consumes about 25% less memory than `Minimal1.hs`. 

## Processed/Minimal31

In addition to the pattern synonyms introduced in `Minimal2.hs`,
we added `H / T` pattern synonyms in an attempt to help
the very large patterns. The `NS f xs` type is defined as:

```haskell
data NS :: (k -> *) -> [k] -> * where
  H :: f x     -> NS f (x ': xs)
  T :: NS f xs -> NS f (x ': xs)
```

We then introduced the pattern synonyms:

```haskell
pattern PatAA x = Here x
pattern PatAB x = There (Here x)
...
```

  - Consumes about 60% less memory than `Minimal1.hs`

## Processed/Minimal32

  We were confident we found a decent hack, and tried compiling
our big examples. Yet, GHC broke in extraordianry ways. We are receiving
type-errors when trying to compile our full code. We generated this repro
to try to trigger this errors here aswell, but it seems to compile just fine.
We will try to make the library code available ASAP so people can reproduce
this behavior.

  Nevertheless, `Minimal32` has the same pattern synonyms as `Minimal31`,
but it has many more patterns.

  - This reproducible consumes about 7 GB of ram. 

  - The library code which this reproducible comes from does not compile.
    GHC says it has type errors (dump available in `Raw/Minimal32Errors`). This is seriously weird.

## Processed/Minimal41

  Trying to make the compiler life easier, we have added type-signatures
to our `H/T` pattern synonyms. This has the same *size* as `Minimal1`,
and requires about 65% less memory than `Minimal1.hs`.

## Processed/Minimal42

  Just like `Minimal32`, but with the pattern synonym specialised 
type signatures, yet, it consumes about 10GB of memory. 

  - Shouldn't it consume even less memory?

# Processing a `-ddump-splices`

run `./process-file path/to/output/of/ddump-splices/name.Type`
where `name` is whatever you want and `Type` is the name of 
a file containing definitions for creating the repro.
There must be a file named `Type` in the root of the repository.

